/*
 * Author: Justin Ritter
 * File: IOAgent.java
 * Date: 10/24/2018
 */
package fileio;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.logging.*;

public class IOAgent implements AutoCloseable {

  //error messages
  private static final String errUsage = "Usage: <filename>";
  private static final String errThreadJoin = "error while joining threads";

  //console messages
  private static final String msgCloseIOAgent = "Closing IOAgent";
  private static final String msgNewTransaction = "New Transaction: Operations=";
  private static final String msgRead = "reading bytes from ";
  private static final String msgWrite = "writing bytes to ";

  //class constants
  private static final int BOUND = 5;
  private static final int BUFFERBOUND = 10;

  //class member variables
  private static Logger logger = Logger.getLogger(IOAgent.class.getPackageName());
  private FileDataSource dataSource;
  private ArrayList<Thread> threads = new ArrayList<>();
  private Random rnd = new Random(System.nanoTime());
  //a sort of bulk rate if any transaction call throws an exception

  public IOAgent(String file) throws IOException {
    setFile(file);

    logger.setUseParentHandlers(false);
    ConsoleHandler console = new ConsoleHandler();
    console.setLevel(Level.SEVERE);
    logger.addHandler(console);
  }

  public static void main(String[] args) {
    if(args.length != 1) {
      throw new IllegalArgumentException(errUsage);
    }

    //tries to create an IOAgent
    try(IOAgent agent = new IOAgent(args[0])) {
      agent.go();
    } catch(IOException e) {
      e.printStackTrace();
    }
  }

  /**
   * Transaction handler
   */
  public void go() {
    threads.add(new Thread(() -> {

      while(true) {
        try {
          int numOp = rnd.nextInt(BOUND) + 1;
          logger.info(msgNewTransaction + numOp);
          doSomething(numOp);
        } catch(Exception e) {
          logger.log(Level.WARNING, e.getMessage(), e);
        }
      }
    }));

    for(Thread t : threads) {
      t.start();
    }
  }

  /**
   * Sets the file for IOAgent
   *
   * @param file file to be held by IOAgent
   * @throws IOException if DataSource error
   */
  private void setFile(String file) throws IOException {
    if(file == null) {
      throw new NullPointerException("file name cannot be null");
    }

    dataSource = new FileDataSource(file, logger);
  }

  /**
   * does something
   */
  private void doSomething(int numOp) {
    Transaction transaction = dataSource.newTransaction();
    for(int i = 0; i < numOp; i++) {
      try {
        //generate the next long offset into the file
        long offset = dataSource.getLength() == 0 ? 0 : ThreadLocalRandom.current().nextLong(dataSource.getLength());
        boolean typeOp = rnd.nextBoolean(); /*True: read operation False: write operation*/

        if(typeOp) {
          //if you are trying to read more than what is in the file back the offset off
          if(offset+BUFFERBOUND >= dataSource.getLength()) {
            offset = dataSource.getLength() - offset;
          }

          //read
          byte[] readBytes = transaction.read(offset, BUFFERBOUND);
          logger.log(Level.INFO, msgRead + offset + ": " + Arrays.toString(readBytes));

        } else {
          byte[] writeBytes = nextSection();
          logger.log(Level.INFO, msgWrite + offset + ": " + Arrays.toString(writeBytes));

          //write
          transaction.write(writeBytes, offset);
        }
      } catch(DeadlockDetectedException dde) {
        logger.log(Level.SEVERE, dde.getMessage(), dde);
        System.err.println(dde.getMessage());
        System.exit(1);
      } catch(Exception e) {
        logger.log(Level.WARNING, e.getMessage(), e);
      }
    }
    transaction.close();
  }

  /**
   * Creates a random byte array BUFFERBOUND in length
   * @return randomly generated byte array
   */
  private byte[] nextSection() {
    byte[] ret = new byte[BUFFERBOUND];
    for(int i = 0; i < BUFFERBOUND; i++) {
      ret[i] = (byte) (' ' + rnd.nextInt(95));
    }
    return ret;
  }

  @Override
  public void close() throws IOException {

    //don't wanna close the dataSource before you are done using it
    for(Thread t : threads) {
      try {
        t.join();
      } catch(InterruptedException e) {
        logger.log(Level.SEVERE, errThreadJoin, e);
      }
    }
    logger.info(msgCloseIOAgent);
    dataSource.close();
  }
}
