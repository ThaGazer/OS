/*
 * Author: Justin Ritter
 * File: IOAgent.java
 * Date: 10/24/2018
 */
package fileio;

import java.io.File;
import java.io.IOException;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

public class IOAgent implements AutoCloseable {

  //error messages
  private static final String errUsage = "Usage: <filename>";

  //logging messages
  private static final String msgFileCreation = "created a new file: ";

  //class constants
  private static final int BOUND = 5;
  private static final int BUFFERBOUND = 5;

  //class member variables
  private static Logger logger = Logger.getLogger(IOAgent.class.getPackageName());
  private FileDataSource dataSource;


  public IOAgent(File file) throws IOException {
    setFile(file);
  }

  public static void main(String[] args) {
    if(args.length != 1) {
      throw new IllegalArgumentException(errUsage);
    }

    //tries to create an IOAgent
    try(IOAgent agent = new IOAgent(new File(args[0]))) {
      agent.go();
    } catch(IOException e) {
      e.printStackTrace();
    }
  }

  public void go() {
    new Thread(() -> {
      while(true) {
        try {
          doSomething();
        } catch(Exception e) {
          logger.log(Level.WARNING, e.getMessage(), e);
        }
      }
    }).start();
  }

  /**
   * Sets the file for IOAgent
   * @param file file to be held by IOAgent
   * @throws IOException if DataSource error
   */
  private void setFile(File file) throws IOException {
    if(file.createNewFile()) {
      logger.info(msgFileCreation + file.getName());
    }

    dataSource = new FileDataSource(file, logger);
  }

  /**
   * does something
   * @throws IOException if DataSource error
   */
  private void doSomething() throws IOException {
    Random rnd = new Random(System.nanoTime());
    int numOp = rnd.nextInt(BOUND);

    for(int i = 0; i < numOp; i++) {
      Transaction transaction = dataSource.newTransaction();

      long offset = nextLong(rnd, dataSource.getLength());
      boolean typeOp = rnd.nextBoolean(); /*True: read operation False: write operation*/

      if(typeOp) {
        transaction.read(offset, BUFFERBOUND);
      } else {
        transaction.write(nextSection(), offset);
      }
      transaction.close();
    }
  }

  /**
   * Creates a random byte array BUFFERBOUND in length
   * @return randomly generated byte array
   */
  private byte[] nextSection() {
    byte[] ret = new byte[BUFFERBOUND];
    new Random(System.nanoTime()).nextBytes(ret);
    return ret;
  }

  /**
   * generates a random long number between 0 and bound
   * @param random random generator
   * @param bound bound for the number
   * @return a randomly generated long number
   */
  private long nextLong(Random random, long bound) {
    if (bound<=0) {
      throw new IllegalArgumentException("n must be positive");
    }

    if ((bound & -bound) == bound) { // i.e., n is a power of 2
      return ((bound * random.nextLong()) >> 31);
    }

    long bits, val;
    do {
      bits = (random.nextLong() << 1) >>> 1;
      val = bits % bound;
    } while (bits-val+(bound-1) < 0L);
    return val;
  }

  @Override
  public void close() throws IOException {
    dataSource.close();
  }
}
