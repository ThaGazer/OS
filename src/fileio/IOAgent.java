/*
 * Author: Justin Ritter
 * File: IOAgent.java
 * Date: 10/24/2018
 */
package fileio;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

public class IOAgent implements AutoCloseable {

  //error messages
  private static final String errUsage = "Usage: <filename>";
  private static final String errExceptionLimit = "The Reasonable Exception limit was reached";
  private static final String errThreadJoin = "error while joining threads";

  //console messages
  private static final String msgCloseIOAgent = "Closing IOAgent";
  private static final String msgNewTransaction = "New Transaction: Operations=";
  private static final String msgRead = "reading bytes from ";
  private static final String msgWrite = "writing bytes to ";

  //class constants
  private static final int BOUND = 5;
  private static final int BUFFERBOUND = 10;
  private static final int EXCEPTIONLIMIT = 20;

  //class member variables
  private static Logger logger = Logger.getLogger(IOAgent.class.getPackageName());
  private FileDataSource dataSource;
  private ArrayList<Thread> threads = new ArrayList<>();
  private int exceptionCounter = 0;
  Random rnd = new Random(System.nanoTime());

  public IOAgent(String file) throws IOException {
    setFile(file);
  }

  public static void main(String[] args) {
    if(args.length != 1) {
      throw new IllegalArgumentException(errUsage);
    }

    //tries to create an IOAgent
    try(IOAgent agent = new IOAgent(args[0])) {
      agent.go();
    } catch(IOException e) {
      e.printStackTrace();
    }
  }

  public void go() {
    threads.add(new Thread(() -> {

      while(true) {
        try {
          int numOp = rnd.nextInt(BOUND) + 1;
          logger.info(msgNewTransaction + numOp);
          doSomething(numOp);
        } catch(Exception e) {
          logger.log(Level.WARNING, e.getMessage(), e);
        }
      }
    }));

    for(Thread t : threads) {
      t.start();
    }
  }

  /**
   * Sets the file for IOAgent
   *
   * @param file file to be held by IOAgent
   * @throws IOException if DataSource error
   */
  private void setFile(String file) throws IOException {
    if(file == null) {
      throw new NullPointerException("file name cannot be null");
    }

    dataSource = new FileDataSource(file, logger);
  }

  /**
   * does something
   *
   * @throws IOException if DataSource error
   */
  private void doSomething(int numOp) throws IOException {

    Transaction transaction = dataSource.newTransaction();
    for(int i = 0; i < numOp; i++) {
      try {
        long offset = nextLong(rnd, dataSource.getLength());
        boolean typeOp = rnd.nextBoolean(); /*True: read operation False: write operation*/

        if(typeOp) {
          byte[] readBytes = transaction.read(0, BUFFERBOUND);
          logger.log(Level.INFO, msgRead + offset + ": " + Arrays.toString(readBytes));

        } else {
          byte[] writeBytes = nextSection();
          logger.log(Level.INFO, msgWrite + offset + ": " + Arrays.toString(writeBytes));
          transaction.write(writeBytes, offset);
        }
      } catch(Exception e) {
        logger.log(Level.WARNING, e.getMessage(), e);
        exceptionCounter++;

        if(exceptionCounter >= EXCEPTIONLIMIT) {
          logger.log(Level.SEVERE, errExceptionLimit);
          System.exit(1);
        }
      }
    }
    transaction.close();
  }

  /**
   * Creates a random byte array BUFFERBOUND in length
   *
   * @return randomly generated byte array
   */
  private byte[] nextSection() {
    byte[] ret = new byte[BUFFERBOUND];
    for(int i = 0; i < BUFFERBOUND; i++) {
      ret[i] = (byte) (' ' + rnd.nextInt(95));
    }
    return ret;
  }

  /**
   * generates a random long number between 0 and bound
   *
   * @param random random generator
   * @param bound  bound for the number
   * @return a randomly generated long number
   */
  private long nextLong(Random random, long bound) {
    if(bound < 0) {
      throw new IllegalArgumentException("n must be positive");
    }
    if(bound == 0) {
      return 0;
    }

    if((bound & -bound) == bound) { // i.e., n is a power of 2
      return ((bound * random.nextLong()) >> 31);
    }

    long bits, val;
    do {
      bits = (random.nextLong() << 1) >>> 1;
      val = bits % bound;
    } while(bits - val + (bound - 1) < 0L);
    return val;
  }

  @Override
  public void close() throws IOException {

    for(Thread t : threads) {
      try {
        t.join();
      } catch(InterruptedException e) {
        logger.log(Level.SEVERE, errThreadJoin, e);
      }
    }
    logger.info(msgCloseIOAgent);
    dataSource.close();
  }
}
